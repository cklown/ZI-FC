<html>
<head>
	<title>Testing Hide Fields</title>
	<script data-src="FormComplete.js">
	
	
	(function() {
	
	/** Configurations
	 *  
	 *   dynamic
	 *     boolean; if true, we will observe the formContainer element and wait for the form to be created. Not needed if form exist in DOM at load.
	 *  
	 *   formSelector
	 *     query selector value, example #FormID, .FormClass, Form[Attribute=Value]; This is used to locate the form within a document.
	 *  
	 *   formContainer
	 *     query selector value, example #FormContainerID, .FormContainerClass, FormContainer[Attribute=Value]; This is used to locate the form container within a document. This is only needed if 'dynamic' is true. Default value: body.
	 *  
	 *   excludedFields
	 *     text value(s); specify 1 or more fields to exclude from form shortenting logic. By default all input and select fields except for email will be hidden, and all hidden fields that are not populated on email match will be unhidden.
	 *   
	 */
	var configurations = {
		dynamic: false,  // set to true if form does not exist imediatly in document.
		formSelector: '#example1',
		formContainer: 'body',
		excludedFields: ['name2', 'notreal']  // id, name or class
	}
	
	// Project key. Get this value from FormComplete.
	window.ZIProjectKey = "0281657f921669107410"; 


	// Form Class.
	class ZI_Form {
		
		constructor( data, configurations ) {
			
			console.log('ZI - Constructing form object...', data, configurations);
			
			// Store configurations.
			this.configurations = configurations;

			// Store context where form resides. This searches sourceless iframes as well.
			this.context = this.getContext(data.formSelector);
			
			// Dynamic enabled?
			if (this.configurations['dynamic']) {
				
				// Define Mutation Observer 
				const formWatch = function(mutationsList, observer) {
					for(const mutation of mutationsList) {
						if (mutation.type === 'childList') {
							for (const e of mutation.addedNodes) {
								if (e.tagName.toLowerCase() === 'form') {
									
									console.log('ZI - Form added to ' + this.configurations['formContainer'] + '.');

									// Maybe check here... data.formSelector == e.id || ...
									this.readyForm(data);
									
									// Stop observer.
									observer.disconnect();

								}
							}
						}
					}
				};
				
				const watchContainer = this.context.querySelector(this.configurations['formContainer']);// using form context... hope things play nice...
				if ( watchContainer !== null ) {

					// Create observer instance linked to formWatch callback
					const observer = new MutationObserver(formWatch);

					// Start observing formContainer for mutations.
					observer.observe( watchContainer, {childList:true} );

				} else {

					console.log('ZI - Form container ('+ this.configurations['formContainer'] +') not found. Recommended default: body');

				}

			} else {
			
				// Ready form.
				this.readyForm(data);
			
			}

		}

		// Get context for form.
		getContext(selector) {
			
			var iframes = document.getElementsByClassName('hs-form-iframe');
			if(iframes) {
				for( var i=0; i < iframes.length; i+=1 ) {
					if( iframes[i].contentDocument.querySelector(selector) )
						return iframes[i].contentDocument;
				}
			}
			
			return document;
			
		}

		// Ready form when form is loaded.
		readyForm(data) {
			
			console.log('ZI - Readying form...');
			data.inputs.forEach(function(input){this.readyField(this.context.querySelector(data.formSelector+' '+input));});
			document.getElementById('ZI_AF').remove();// Remove Antiflicker style.
			//this.context.getElementById('ZI_AF').remove();// Remove Antiflicker style.  !! At present, style is only populated in primary context, and not in iframes if that is where form resides.
			
		}
		
		// Update form when a match is found by ZI API.
		updateForm(data) {
			
			console.log('ZI - Updating form...');
			data.inputs.forEach(function(input){this.updateField( this.context.querySelector(data.formSelector+' '+input), input, data );});
			
		}

		// Hide mapped field that is not email nor an excluded field in configurations.
		readyField(field) {
			
			// Analyze field.
			const isField = ['INPUT', 'SELECT'].includes(field.nodeName);
			const ignoredType = field.hasAttribute('type') && [ 'reset', 'button', 'submit', 'hidden', 'radio' ].includes(field.getAttribute('type').toLowerCase());//! should radio be excluded?
			const isEmail = ['id', 'name', 'class'].some(identifier => field[identifier] && field[identifier].includes('email') || field.classList.contains('email'));
			const isExcluded = excludedFields.includes(field.id) || excludedFields.includes(field.name) || field.classList.contains(excludedFields);

			if (isField && !ignoredType && !isEmail && !isExcluded) {
				const fieldContainer = this.findContainer(field);
				if (fieldContainer) {fieldContainer.style.display = 'none';}
				else {console.log('ZI - Field Container not found.', field);}
			}
			
		}
		
		// Update mapped field that is not email nor an excluded field in configurations. If an element is hidden by end-user and is excluded, we will not unhide element spite it being hidden + unpopulated with data, end-user will need to unhide with their own logic if excluded. 
		updateField( field, input, data ) {
			
			// If field populated, ignore.
			if ( data[input] != undefined ) {return;}

			// Find field container.
			const fieldContainer = findContainer(field);
			if (!fieldContainer) {
				console.log('ZI - Field Container not found.', field);
				return;
			}

			// If field is displayed, ignore.
			if ( fieldContainer.style.display != 'none' ){return;}

			// Analyze field.
			const isField = ['INPUT', 'SELECT'].includes(field.nodeName);
			const ignoredType = field.hasAttribute('type') && [ 'reset', 'button', 'submit', 'hidden', 'radio' ].includes(field.getAttribute('type').toLowerCase());//! should radio be excluded?
			const isExcluded = excludedFields.includes(field.id) || excludedFields.includes(field.name) || field.classList.contains(excludedFields);

			// Field was not populated and is not excluded, display it.
			if ( isField && !ignoredType && !isExcluded ) {fieldContainer.style.display = '';}

		}
		
	}

    // Ensure fc variable is initialized.
    if(!window._zi_fc){window._zi_fc = {};}
	
	// Initialize when ready.
	window._zi_fc.onReady = function( data, configurations ) {
		ZI_Form = new ZI_Form( data, configurations );
	}
	
	// Listen for ZI API matches.
	window._zi_fc.onMatch = function(data) {
		ZI_Forms.updateForm(data);
	}

	// Antiflicker.
	//!!! At present, this only applies in the doc, not inside iframes.
	const s = document.createElement('style');
	s.id = 'ZI_AF';
	s.innerHTML = `${configurations['formSelector']} {opacity:0 !important;}`;// The CSS to be loaded which dynamically will populate the form selector.
	document.head.appendChild(s);
	
	// Add base logic once document has loaded.
	document.addEventListener('DOMContentLoaded', function() {

		var zi = document.createElement('script');
		(zi.type = 'text/javascript'),
		(zi.async = true),
		(zi.src = 'https://js.zi-scripts.com/zi-tag.js'),
		document.body.appendChild(zi);
	
	}, { once:true, capture:true });
	
	console.log('ZI - FormComplete snippet loaded.');
	
})();
	
	
	</script>
	<style>
		body {
			background-color:#EEEEEE;
			padding:10px;
			font:10px Verdana;
			color:#222;
			line-height:12px;
		}
		form {
			background-color:#FFFFFF;
			border:1px solid #DEDEDE;
			padding:10px;
			margin:10px 0px;
			display:block;
		}
		h3 {
			line-height:20px;
		}
		input,
		select {
			background-color:#FFFFFF;
			border:1px solid #DEDEDE;
			padding:10px;
			margin:3px 0px;
			height:32px;
			width:300px;
			padding:6px;
		}
		button,
		input[type=reset],
		input[type=button],
		input[type=submit] {
			width:150px;
		}
		label {
			display:inline-block;
			width:50px;
		}
	</style>
	<script>
	
		// Create a form dynamically to test mutation lisenter.
		setTimeout(function(){
			const form = document.createElement('form');
			form.id = 'example4';
			form.innerHTML = `
			<h3>Example 4: Dynamic form, no field containers or labels. Does not exist in DOM @ load completion</h3>
			<input id="email" value="Email"><br><input id="name" value="Name"><br>
			<input id="company" value="Company"><br>
			<select id="country">
				<option value="1">USA</option>
				<option value="2">Japan</option>
				<option value="3">Canada</option>
			</select><br>
			<input type="button" value="Continue">
			`;
			document.body.appendChild(form);
		},2000);
	
	</script>
	<!--/
	
		This script must do the following:
			Hide form elements (including any container items) that are not excluded and exclude any element that contains 'email' in the id/name/class value.
			prevent flickering of the form as items are hidden
			have unhide functionality when receiving a json response from the endpoint that returns a value for a field
			has the added option to also hide the field (check if the field is already hidden, and if so, add to ignore list)

	/-->
</head>
<body>

<form id="example1">
	<h3>Example 1: Basic form, no field containers or labels.</h3>
	<input id="email" value="Email"><br>
	<input id="name" value="Name"><br>
	<input id="company" value="Company"><br>
	<select id="country">
		<option value="1">USA</option>
		<option value="2">Japan</option>
		<option value="3">Canada</option>
	</select><br>
	<input type="button" value="Continue">
</form>


<form id="example2">
	<h3>Example 2: Simple form, label + no attribute div container.</h3>
	<div>
		<label for="email2">Email</label>
		<input id="email2" value="Email">
	</div>

	<div>
		<label for="name2">Name</label>
		<input id="name2" value="Never Exclude">
	</div>

	<div>
		<label for="company2">Company</label>
		<input id="company2" value="Company">
	</div>

	<div>
		<label for="country2">Country</label>
		<select id="country2">
			<option value="1">USA</option>
			<option value="2">Japan</option>
			<option value="3">Canada</option>
		</select>
	</div>

	<input type="button" value="Continue">

</form>


<form id="example3">
	<h3>Example 3: Simple form, label + span + no attribute div  + div container with class.</h3>
	<div class="fieldx">
		<div>
			<label for="email2">Email</label>
			<input id="email2" value="Email">
			<span class="instructions"><span>
		</div>
	</div>

	<div class="fieldx">
		<div>
			<label for="name2">Name</label>
			<input id="name2" value="Never Exclude">
			<span class="instructions"><span>
		</div>
		<span class="notes"><span>
	</div>

	<div class="fieldx">
		<div>
			<label for="company2">Company</label>
			<input id="company2" value="Company">
			<span class="instructions"><span>
		</div>
		<span class="notes"><span>
	</div>

	<div class="fieldx">
		<div>
			<label for="country2">Country</label>
			<select id="country2">
				<option value="1">USA</option>
				<option value="2">Japan</option>
				<option value="3">Canada</option>
			</select>
			<span class="instructions"><span>
		</div>
	</div>

	<input type="button" value="Continue">

</form>






</body>
</html>
